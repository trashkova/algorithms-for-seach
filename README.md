<h2>Алгоритмы поиска</h2>
Вся информация взята с <a href="https://proglib.io/p/6-search-algorithms-java">ссылка-источника</a>.

<h4>Линейный поиск - алгоритм поиска элемента методом перебора.</h4>
Описание алгоритма:<br>
<ol>
<li> ищем элемент в заданной структуре данных, пока не достигнем конца структуры.</li>
<li> при нахождении элемента возвращается его позиция в структуре данных. Если элемент не найден, возвращаем -1.</li>
</ol>
Временная сложность: в худшем случае O(N)<br>
Пространственная сложность: О(1)<br>
<br>
Применение: <br>
Неэффективен из-за линейного увеличения временной сложности.<br>
Можно использовать для малого, несортированного набора данных, который не увеличивается в размерах.

<h4>Бинарный поиск - алгоритм поиска элемента в отсортированном массиве, посредством дробления массива на половинки.</h4>
Описание алгоритма:<br>
<ol>
<li> найти элемент по середине между границами, сравнить с искомым.</li>
<li> если элемент по середине равен искомому -> поиск завершен.</li>
<li> если искомое больше, сузить область поиска - отбросить левую часть, сдвигая левую границу до элемент по середине + 1.</li>
<li> если искомое меньше, сузить область поиска - отбросить правую часть, сдвигая правую часть до элемент по середине - 1.</li>
<li> поиск аканчивается, когда границы совпадают -> элемент не найден.</li>
</ol>
Временная сложность: O(log (N))<br>
Пространственная сложность: О(1)  для итеративного подхода,  O(log (N)) для рекурсивного<br>
<br>
Применение: <br>
используется в большинстве библиотек и используется с отсортированными структурами данных.

<h4>Интерполяционный поиск - алгоритм поиска элемента в отсортированном массиве, где поиск происходит подобно бинарному поиску, но оценка новой области поиска производится по расстоянию между ключом и текущим значением элемента.</h4>

Формула интерполяции для поиска возможной лучшей позиции для существующего элемента :<br>
i = i1 + (x - k1)/(k2 - k1) * (x2 - x1) <br>
где х - элемент поиска, k1 и k2 - значения ключей, i1 и i2 - соответсвующие индексы ключей, i - индекс разделительного элемента<br>
<br>
Временная сложность: в лучшем случае O(log log N), при неравномерном распределении элементов сложность сопоставима с временной сложностью линейного алгоритма, которая = O(N).<br>
Пространственная сложность: О(1)<br>
<br>
Применение: <br>
полезно применять для равномерно распределенных данных вроде телефонной книги.

<h4>Поиск прыжками - алгоритм поиска элемента в отсортированном массиве, посредством прыжков исключительно вперед на интервал sqrt(arraylength).</h4>
Описание алгоритма:<br>
<ol>
<li> прыгаем вперед на интервал sqrt(arraylength), пока не достигнем элемента большего, чем текущий элемент или конца массива.</li>
<li> при каждом прыжке записывается предыдущий шаг.</li>
<li> прыжки прекращаются, когда найден элемент больше искомого.</li>
<li> если искомое меньше, сузить область поиска - отбросить правую часть, сдвигая правую часть до элемент по середине - 1.</li>
<li> запускаем линейный поиск между предыдущим и текущим шагами (это уменьшает поле поиска и делает линейный поиск жизнеспособным вариантом).</li>
</ol>
Временная сложность: O(sqrt (N))<br>
Пространственная сложность: О(1)<br>
<br>
Применение: <br>
используется поверх бинарного поиска, когда прыжки в обратную сторону затратны.<br>
Это ограничение возникает, когда мы используем вращающиеся носители, такие как диски, когда легко двигаться вперед, но многократно прыгать в обратном направлении дорого.

<h4>Экспоненциальный поиск - алгоритм поиска элемента в отсортированном массиве путём перехода в экспоненциальные позиции, то есть во вторую степень.</h4>
Описание алгоритма:<br>
<ol>
<li> проводим поиск элемента больше искомого для минимизации диапазона поиска: увеличиваем диапазон, умножая его на 2, и снова проверяем, достигли ли мы элемента больше искомого или конца массива.</li>
<li> при нахождении элемента больше искомого мы выходим из цикла.</li>
<li> выполняем бинарный поиск с startIndex в качестве range/2 и lastIndex в качестве range, где range - диапазон поиска который мы вычислили ранее.</li>
</ol>
Временная сложность: в худшем случае O(log (N))<br>
Пространственная сложность: О(1)<br>
<br>
Применение: <br>
используется с большими массивами, когда бинарный поиск затратен, т.к. разделяет данные на более доступные для поиска разделы.
